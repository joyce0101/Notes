# 冒泡排序
## 一、算法基本思想  
  1、从无序队列的头部开始，两两比较，根据大小交换位置，最后将最大的元素交换到无序队列的队尾，成为有序队列的一部分，下次继续这个过程。时间复杂度为O（n2）。  
  2、具体过程如下：
  <div align="center"> <img src="https://github.com/joyce0101/Notes/blob/master/src/%E5%BF%AB%E6%8E%92.png"/> </div>  

## 二、具体实现  
~~~c++  
void pop_sort(int a[],int len)
{
    int i,j;
    for(int i=0;i<len;i++)
    {
        for(int j=0;j<len-i-1;j++)
        {
            if(a[j]>a[j+1])
                swap(a[j],a[j+1]);
        }
    }
}
~~~
# 插入排序
wiki地址：https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F#C++
## 一、基本思想
  1、从第一个元素开始，该元素被认为已经被排序
  2、取出下一个元素，在已经被排好序的元素序列中从后向前扫描
  3、如果该元素小于新元素，将该元素移到新元素的前面
  4、直到该元素大于或者等于新元素
  5、重复步骤2~5
  <div align="center"><img src="https://github.com/joyce0101/Notes/blob/master/src/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.PNG"/></div>  
  时间复杂度：O（n2）

## 二、具体实现
~~~c++
void insert_sort(int a[],int len)
{
    for(int i=1;i<len;i++)
    {
        int key=a[i];
        for(int j=i-1;j>=0&&a[j]>key;j--)
        {
            a[j+1]=a[j];
            a[j]=key;
        }
    }
}
~~~
# 快排
wiki地址：https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F  
快排使用分治法策略把一个序列分为两个子序列  
步骤为：  
  1、从数列中挑出一个数作为基准
  2、重新排序数列，将比基准小的放在基准左边，比基准大的放在基准右边，在这个分区结束之后，该基准位于数列中他本该的位置，这个操作称为分区操作。  
  3、递归的把小于基准值的子数列和大于基准值的子序列排序。
## 基本思想
  1、分区操作：
  （1）设置两个指针，一个指向头部，一个指向尾部，头指针找到比基准大的与尾指针找到的比基准小的元素交换，直到两个指针相等。j指针为元素的最终位置。  
  （2）链表快排：两个指针i、j同时指向头部，i指针的位置为元素的基准位置，j从头到尾遍历，当找到比基准小的元素，交换a[i]和a[j]，同时i+1，意味着比基准小的元素的个数。  
  *时间复杂度：O（nlogn）~O（n2）*  
  最优时，划分的子问题包含（n/2）和（n/2-1）个元素  
  T（n）=2T(n/2)+O(n)  
  T(n)=O(nlogn)   
  最坏时，待排序的序列为正序或者逆序  
  T(n)=T(n-1)+T(0)+O(n)  
  T(n)=O(n2)  
  2、递归排序子序列
## 具体实现
~~~c++
int my_partition1(int a[],int low,int up)
{
    int pivot=a[low];
    int i=low;
    int j=up;
    while(true)
    {
        while(a[i]<pivot)i++;
        while(a[j]>pivot)j--;
        if(i>=j)
            return j;
        swap(a[i],a[j]);
    }
}
int my_partition2(int a[],int low,int high)
{
    int pivot=a[high];
    int i=low;
    for(int j=low;j<high;j++)
    {
        if(a[j]<=pivot)
        {
            swap(a[i],a[j]);
            i++;
        }
    }
    swap(a[i],a[high]);
    return i;
}
void quick_sort(int a[],int low,int high)
{
    if(low<high)
    {
        int mid=my_partition2(a,low,high);
        //cout<<mid<<endl;
        quick_sort(a,low,mid-1);
        quick_sort(a,mid+1,high);
    }
}
~~~
# 归并排序
wiki地址：https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F  
## 基本思想：  
  1、分成小问题  
  2、将分开的子数组合并成新数组  
<div align="center"><img src="https://github.com/joyce0101/Notes/blob/master/src/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.PNG"/></div>
<div align="center"><img src="https://github.com/joyce0101/Notes/blob/master/src/%E5%90%88%E5%B9%B61.png"/></div>
<div align="center"><img src="https://github.com/joyce0101/Notes/blob/master/src/%E5%90%88%E5%B9%B62.png"/></div>

## 算法实现：
~~~c++
~~~
